package shell

import (
	"context"
	"fmt"
	"io"
	"os"
	"os/exec"
	"os/signal"
	"strings"
	"syscall"
	"time"

	"docknaut/config"
	"docknaut/i18n"
	"docknaut/internal/engine"
	"docknaut/internal/executor"
	"docknaut/internal/parser"
	"docknaut/themes"

	"github.com/c-bata/go-prompt"
)

type Shell struct {
	cwd           string
	config        *config.Config
	history       []string
	mappingEngine engine.MappingEngine
	commandParser parser.CommandParser
	shellExecutor executor.ShellExecutor
	dataPath      string
}

func NewShell(cfg *config.Config, dataPath string) *Shell {
	cwd, _ := os.Getwd()

	// „Éá„Éº„Çø„Éë„Çπ„ÇíË®≠ÂÆöÔºà„Éá„Éï„Ç©„É´„Éà„ÅØ ./dataÔºâ
	if dataPath == "" {
		dataPath = "data"
	}

	// Êñ∞„Åó„ÅÑ„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÇíÂàùÊúüÂåñ
	mappingEngine := engine.NewMappingEngine(dataPath)
	commandParser := parser.NewCommandParser()
	shellExecutor := executor.NewShellExecutor(mappingEngine)

	// „Éû„ÉÉ„Éî„É≥„Ç∞„Éá„Éº„Çø„ÇíË™≠„ÅøËæº„Åø
	if err := mappingEngine.LoadMappings(); err != nil {
		fmt.Printf(i18n.T("shell.config_load_warning")+"\n", err)
	}

	shell := &Shell{
		cwd:           cwd,
		config:        cfg,
		history:       []string{},
		mappingEngine: mappingEngine,
		commandParser: commandParser,
		shellExecutor: shellExecutor,
		dataPath:      dataPath,
	}

	// WindowsÁí∞Â¢É„ÅÆÂàùÊúüÂåñ
	shell.initializeWindowsEnvironment()

	// Windows ANSI „Çµ„Éù„Éº„Éà„ÇíÊúâÂäπÂåñ
	enableWindowsAnsiSupport()

	// Ë®≠ÂÆö„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„Åø
	if err := cfg.LoadConfigFile(); err != nil {
		fmt.Printf(i18n.T("shell.config_load_warning")+"\n", err)
	}

	return shell
}

func (s *Shell) Start() error {
	// Ë®≠ÂÆö„Éï„Ç°„Ç§„É´„ÇíÂÜçË™≠„ÅøËæº„Åø
	if err := s.config.LoadConfigFile(); err != nil {
		fmt.Printf(i18n.T("shell.config_load_warning"), err)
	}

	// Ëµ∑Âãï„Éê„Éä„Éº„ÇíË°®Á§∫
	if s.config.BannerEnabled {
		banner := themes.RenderBanner(s.config.BannerStyle)
		fmt.Print(banner)
	}

	fmt.Print(i18n.T("app.docker_only_welcome"))

	// go-prompt„Çí‰ΩøÁî®„Åó„Åü„Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„Éñ„Éó„É≠„É≥„Éó„Éà
	p := prompt.New(
		s.executor,
		s.Completer,
		prompt.OptionTitle("üê≥ Docsh (Docker-Only)"),
		prompt.OptionHistory(s.history),
		prompt.OptionLivePrefix(s.getLivePrefix),
		prompt.OptionPreviewSuggestionTextColor(prompt.Blue),
		prompt.OptionSelectedSuggestionBGColor(prompt.LightGray),
		prompt.OptionSuggestionBGColor(prompt.DarkGray),
		prompt.OptionDescriptionBGColor(prompt.Black),
		prompt.OptionDescriptionTextColor(prompt.White),
		prompt.OptionScrollbarThumbColor(prompt.DarkGray),
		prompt.OptionScrollbarBGColor(prompt.Black),
		prompt.OptionMaxSuggestion(16),
	)
	p.Run()

	return nil
}

// executor „ÅØ„Ç≥„Éû„É≥„ÉâÂÆüË°å„ÇíÂá¶ÁêÜ„Åó„Åæ„Åô
func (s *Shell) executor(input string) {
	input = strings.TrimSpace(input)
	if input == "" {
		return
	}

	// Â±•Ê≠¥„Å´ËøΩÂä†ÔºàÈáçË§á„ÇíÈÅø„Åë„ÇãÔºâ
	if len(s.history) == 0 || s.history[len(s.history)-1] != input {
		s.history = append(s.history, input)
		// Â±•Ê≠¥„ÅÆ‰∏äÈôê„ÇíË®≠ÂÆöÔºà‰æãÔºö1000‰ª∂Ôºâ
		if len(s.history) > 1000 {
			s.history = s.history[1:]
		}
	}

	if input == "exit" {
		fmt.Println(i18n.T("app.goodbye"))
		os.Exit(0)
	}

	if err := s.executeCommand(input); err != nil {
		fmt.Printf(i18n.T("app.error")+"\n", err)
	}
}

func (s *Shell) getCurrentDir() string {
	if cwd, err := os.Getwd(); err == nil {
		s.cwd = cwd
		return cwd
	}
	return s.cwd
}

// ExecuteCommand exposes the executeCommand method for external use
func (s *Shell) ExecuteCommand(input string) error {
	return s.executeCommand(input)
}

func (s *Shell) executeCommand(input string) error {
	// „Ç®„Ç§„É™„Ç¢„ÇπÂ±ïÈñã
	if s.config != nil {
		input = s.config.ExpandAlias(input)
	}

	// „Ç≥„Éû„É≥„Éâ„Çí„Éë„Éº„Çπ
	parsedCmd, err := s.commandParser.ParseCommand(input)
	if err != nil {
		return err
	}
	if parsedCmd == nil {
		return nil
	}

	command := parsedCmd.Command
	args := parsedCmd.Args

	// DockerÂ∞ÇÁî®„Ç∑„Çß„É´„ÅÆÂÜÖËîµ„Ç≥„Éû„É≥„Éâ„ÅÆ„ÅøÂá¶ÁêÜ
	switch command {
	case "pwd":
		fmt.Println(s.getCurrentDir())
		return nil
	case "alias":
		return s.handleAliasCommand(args)
	case "theme":
		return s.handleThemeCommand(args)
	case "lang":
		return s.handleLangCommand(args)
	case "config":
		if len(args) > 0 {
			switch args[0] {
			case "show":
				s.showConfig()
			default:
				fmt.Printf(i18n.T("config.unknown_command")+"\n", args[0])
			}
		} else {
			fmt.Println(i18n.T("config.usage"))
		}
		return nil
	case "mapping":
		return s.handleMappingCommand(args)
	case "help":
		s.showHelp()
		return nil
	case "version":
		fmt.Println(i18n.T("app.docker_only_version"))
		return nil
	case "clear", "cls":
		fmt.Print("\033[2J\033[H")
		return nil
	// Docker lifecycle commands
	case "pull":
		if len(args) == 0 {
			return fmt.Errorf(i18n.T("docker.image_name_required"))
		}
		return s.pullImage(args[0])
	case "start":
		if len(args) == 0 {
			return fmt.Errorf(i18n.T("docker.container_name_required"))
		}
		return s.startContainer(args[0])
	case "exec":
		if len(args) < 2 {
			return fmt.Errorf(i18n.T("docker.container_name_required") + " and " + i18n.T("docker.command_required"))
		}
		return s.execInContainer(args[0], args[1:])
	case "stop":
		if len(args) == 0 {
			return fmt.Errorf(i18n.T("docker.container_name_required"))
		}
		return s.stopContainer(args[0])
	case "rm":
		if len(args) == 0 {
			return fmt.Errorf(i18n.T("docker.container_name_required"))
		}
		// Check for --force flag
		force := false
		containerName := args[0]
		if len(args) > 1 {
			for _, arg := range args[1:] {
				if arg == "--force" || arg == "-f" {
					force = true
					break
				}
			}
		}
		return s.removeContainer(containerName, force)
	case "rmi":
		if len(args) == 0 {
			return fmt.Errorf(i18n.T("docker.image_name_required"))
		}
		// Check for --force flag
		force := false
		imageName := args[0]
		if len(args) > 1 {
			for _, arg := range args[1:] {
				if arg == "--force" || arg == "-f" {
					force = true
					break
				}
			}
		}
		return s.removeImage(imageName, force)
	default:
		// DockerÂ∞ÇÁî®„Ç∑„Çß„É´„É¢„Éº„Éâ„Åß„Ç≥„Éû„É≥„ÉâÂÆüË°å
		// „Çπ„Éà„É™„Éº„Éü„É≥„Ç∞„Ç≥„Éû„É≥„Éâ„ÅÆÂ†¥Âêà„ÅØÁâπÂà•„Å™Âá¶ÁêÜ„ÇíË°å„ÅÜ
		isStreaming := isStreamingCommand(parsedCmd)
		if isStreaming {
			return s.executeStreamingCommandDirectly(parsedCmd)
		}

		// ÈÄöÂ∏∏„ÅÆ„Ç≥„Éû„É≥„ÉâÂÆüË°å
		ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
		defer cancel()

		result, err := s.shellExecutor.Execute(ctx, parsedCmd)
		if err != nil {
			// DockerÂ∞ÇÁî®„Ç∑„Çß„É´„ÅÆ„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÇíË°®Á§∫
			fmt.Printf("‚ùå %s\n", result.Error)
			fmt.Println(i18n.T("app.docker_only_available_commands"))
			fmt.Println(i18n.T("app.docker_only_commands_list"))
			fmt.Println(i18n.T("app.docker_only_mapping_help"))
			return nil
		}

		// ÁµêÊûú„ÇíË°®Á§∫
		if result.Output != "" {
			fmt.Print(result.Output)
		}

		// „Éû„ÉÉ„Éî„É≥„Ç∞ÊÉÖÂ†±„ÇíË°®Á§∫
		if result.Mapping != nil {
			fmt.Printf("‚úÖ %s -> %s\n", result.Mapping.LinuxCommand, result.Mapping.DockerCommand)
		}

		return nil
	}
}

func (s *Shell) handleAliasCommand(args []string) error {
	if s.config == nil {
		return fmt.Errorf(i18n.T("config.not_initialized"))
	}

	if len(args) == 0 {
		// ÂÖ®„Ç®„Ç§„É™„Ç¢„Çπ„ÇíË°®Á§∫
		s.config.ListAliases()
		return nil
	}

	// alias name=command „ÅÆÂΩ¢Âºè„ÅßÊñ∞„Åó„ÅÑ„Ç®„Ç§„É™„Ç¢„Çπ„ÇíË®≠ÂÆö
	aliasString := strings.Join(args, " ")
	return s.config.ParseAlias(aliasString)
}

func (s *Shell) handleThemeCommand(args []string) error {
	if len(args) == 0 {
		// Âà©Áî®ÂèØËÉΩ„Å™„ÉÜ„Éº„Éû‰∏ÄË¶ß„ÇíË°®Á§∫
		themes.ListThemes()
		if s.config != nil {
			fmt.Printf(i18n.T("theme.current_theme")+"\n", s.config.Theme)
		}
		return nil
	}

	themeName := args[0]
	if _, exists := themes.GetTheme(themeName); !exists {
		return fmt.Errorf(i18n.T("theme.not_found"), themeName)
	}

	if s.config != nil {
		s.config.Theme = themeName
		fmt.Printf(i18n.T("theme.theme_changed")+"\n", themeName)
	}

	return nil
}

func (s *Shell) handleLangCommand(args []string) error {
	if len(args) == 0 {
		// ÁèæÂú®„ÅÆË®ÄË™ûË®≠ÂÆö„ÇíË°®Á§∫
		currentLang := i18n.GetCurrentLanguage()
		availableLangs := i18n.GetAvailableLanguages()

		fmt.Printf(i18n.T("lang.current_language")+"\n", currentLang)
		fmt.Printf(i18n.T("lang.available_languages") + "\n")
		for _, lang := range availableLangs {
			fmt.Printf("  %s\n", lang)
		}
		return nil
	}

	newLang := args[0]
	availableLangs := i18n.GetAvailableLanguages()

	// ÊåáÂÆö„Åï„Çå„ÅüË®ÄË™û„ÅåÂà©Áî®ÂèØËÉΩ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
	isValid := false
	for _, lang := range availableLangs {
		if lang == newLang {
			isValid = true
			break
		}
	}

	if !isValid {
		return fmt.Errorf(i18n.T("lang.invalid_language"), newLang)
	}

	// Ë®≠ÂÆö„Éï„Ç°„Ç§„É´„Å´Ë®ÄË™ûË®≠ÂÆö„Çí‰øùÂ≠ò
	if s.config != nil {
		if err := s.config.SetLanguage(newLang); err != nil {
			return fmt.Errorf(i18n.T("lang.save_error"), err)
		}
	}

	// i18n„ÇíÂÜçÂàùÊúüÂåñ
	if err := i18n.Init(newLang); err != nil {
		return fmt.Errorf(i18n.T("lang.init_error"), err)
	}

	fmt.Printf(i18n.T("lang.language_changed")+"\n", newLang)
	fmt.Printf(i18n.T("lang.restart_notice") + "\n")

	return nil
}

func (s *Shell) showConfig() {
	fmt.Println(i18n.T("config.show_header"))
	fmt.Printf(i18n.T("config.show_theme")+"\n", s.config.Theme)
	fmt.Printf(i18n.T("config.show_language")+"\n", s.config.Language)

	if s.config.GitHubUser != "" {
		fmt.Printf(i18n.T("config.show_github_user")+"\n", s.config.GitHubUser)
	}

	if s.config.GitHubToken != "" {
		fmt.Printf(i18n.T("config.show_github_token")+"\n", s.config.GitHubToken[:10])
	} else {
		fmt.Println(i18n.T("config.show_github_token_not_set"))
	}

	fmt.Printf(i18n.T("config.show_aliases_count")+"\n", len(s.config.Aliases))
	if len(s.config.Aliases) > 0 {
		fmt.Println(i18n.T("config.show_aliases_header"))
		for name, command := range s.config.Aliases {
			fmt.Printf(i18n.T("config.show_alias_item")+"\n", name, command)
		}
	}

	// Docker „ÅÆÁä∂ÊÖã„ÇíË°®Á§∫
	fmt.Println()
	fmt.Println(i18n.T("config.docker_only_mode_enabled"))
	if s.shellExecutor.IsDockerAvailable() {
		fmt.Println(i18n.T("config.docker_available"))
	} else {
		fmt.Println(i18n.T("config.docker_not_available"))
	}

	// „Éû„ÉÉ„Éî„É≥„Ç∞Áµ±Ë®à„ÇíË°®Á§∫
	mappings := s.mappingEngine.GetAllMappings()
	fmt.Printf("\n"+i18n.T("config.total_mappings")+"\n", len(mappings))
	categories := s.mappingEngine.GetCategories()
	fmt.Printf(i18n.T("config.available_categories")+"\n", strings.Join(categories, ", "))
	fmt.Println("\n" + i18n.T("config.linux_commands_disabled"))
}

// getLivePrefix „ÅØÂãïÁöÑ„Å™„Éó„É≠„É≥„Éó„Éà„Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„Çπ„ÇíËøî„Åó„Åæ„Åô
func (s *Shell) getLivePrefix() (string, bool) {
	return s.buildPrompt(), true
}

// handleMappingCommand „ÅØ mapping „Ç≥„Éû„É≥„Éâ„ÇíÂá¶ÁêÜ„Åó„Åæ„Åô
func (s *Shell) handleMappingCommand(args []string) error {
	if len(args) == 0 {
		// ÂÖ®„Éû„ÉÉ„Éî„É≥„Ç∞‰∏ÄË¶ß„ÇíË°®Á§∫
		s.listAllMappings()
		return nil
	}

	switch args[0] {
	case "list":
		if len(args) > 1 {
			return s.listMappingsByCategory(args[1])
		}
		s.listAllMappings()
		return nil
	case "search":
		if len(args) > 1 {
			return s.searchMappings(strings.Join(args[1:], " "))
		}
		return fmt.Errorf(i18n.T("mappings.search_no_results"), "")
	case "show":
		if len(args) > 1 {
			return s.showMapping(args[1])
		}
		return fmt.Errorf("show requires a command name")
	default:
		return fmt.Errorf("unknown mapping command: %s", args[0])
	}
}

// listAllMappings „ÅØÂÖ®„Éû„ÉÉ„Éî„É≥„Ç∞„Çí‰∏ÄË¶ßË°®Á§∫„Åó„Åæ„Åô
func (s *Shell) listAllMappings() {
	fmt.Println(i18n.T("commands.mapping_help"))
	fmt.Println()

	categories := s.mappingEngine.GetCategories()
	for _, category := range categories {
		fmt.Printf("=== %s ===\n", i18n.T("categories."+category))
		categoryMappings, _ := s.mappingEngine.ListByCategory(category)
		for _, mapping := range categoryMappings {
			fmt.Printf("  %s -> %s\n", mapping.LinuxCommand, mapping.DockerCommand)
			if mapping.Description != "" {
				fmt.Printf("    %s\n", mapping.Description)
			}
		}
		fmt.Println()
	}
}

// listMappingsByCategory „ÅØ„Ç´„ÉÜ„Ç¥„É™Âà•„Éû„ÉÉ„Éî„É≥„Ç∞„ÇíË°®Á§∫„Åó„Åæ„Åô
func (s *Shell) listMappingsByCategory(category string) error {
	mappings, err := s.mappingEngine.ListByCategory(category)
	if err != nil {
		return err
	}

	if len(mappings) == 0 {
		fmt.Printf(i18n.T("mappings.category_not_found")+"\n", category)
		return nil
	}

	fmt.Printf("Mappings for category '%s':\n\n", i18n.T("categories."+category))
	for _, mapping := range mappings {
		fmt.Printf("%s -> %s\n", mapping.LinuxCommand, mapping.DockerCommand)
		fmt.Printf("  %s: %s\n", i18n.T("help.description"), mapping.Description)
		fmt.Printf("  %s: %s\n", i18n.T("help.examples"), mapping.DockerExample)
		if len(mapping.Notes) > 0 {
			fmt.Printf("  %s: %s\n", i18n.T("help.notes"), strings.Join(mapping.Notes, ", "))
		}
		fmt.Println()
	}
	return nil
}

// searchMappings „ÅØ„Éû„ÉÉ„Éî„É≥„Ç∞„ÇíÊ§úÁ¥¢„Åó„Åæ„Åô
func (s *Shell) searchMappings(query string) error {
	mappings, err := s.mappingEngine.SearchCommands(query)
	if err != nil {
		return err
	}

	if len(mappings) == 0 {
		fmt.Printf(i18n.T("mappings.search_no_results")+"\n", query)
		return nil
	}

	fmt.Printf("Search results for '%s':\n\n", query)
	for _, mapping := range mappings {
		fmt.Printf("%s -> %s\n", mapping.LinuxCommand, mapping.DockerCommand)
		fmt.Printf("  Category: %s\n", i18n.T("categories."+mapping.Category))
		fmt.Printf("  %s: %s\n", i18n.T("help.description"), mapping.Description)
		fmt.Println()
	}
	return nil
}

// showMapping „ÅØÁâπÂÆö„ÅÆ„Éû„ÉÉ„Éî„É≥„Ç∞Ë©≥Á¥∞„ÇíË°®Á§∫„Åó„Åæ„Åô
func (s *Shell) showMapping(command string) error {
	mapping, err := s.mappingEngine.FindByLinuxCommand(command)
	if err != nil {
		mapping, err = s.mappingEngine.FindByDockerCommand(command)
		if err != nil {
			return fmt.Errorf(i18n.T("mappings.not_found"), command)
		}
	}

	fmt.Printf("Mapping Details for '%s':\n\n", command)
	fmt.Printf("Linux Command: %s\n", mapping.LinuxCommand)
	fmt.Printf("Docker Command: %s\n", mapping.DockerCommand)
	fmt.Printf("Category: %s\n", i18n.T("categories."+mapping.Category))
	fmt.Printf("%s: %s\n", i18n.T("help.description"), mapping.Description)
	fmt.Printf("Linux Example: %s\n", mapping.LinuxExample)
	fmt.Printf("Docker Example: %s\n", mapping.DockerExample)

	if len(mapping.Notes) > 0 {
		fmt.Printf("\n%s:\n", i18n.T("help.notes"))
		for _, note := range mapping.Notes {
			fmt.Printf("  - %s\n", note)
		}
	}

	if len(mapping.Warnings) > 0 {
		fmt.Printf("\n%s:\n", i18n.T("help.warnings"))
		for _, warning := range mapping.Warnings {
			fmt.Printf("  ‚ö†Ô∏è  %s\n", warning)
		}
	}

	return nil
}

// isStreamingCommand „Çπ„Éà„É™„Éº„Éü„É≥„Ç∞„Ç≥„Éû„É≥„Éâ„Åã„Å©„ÅÜ„Åã„ÇíÂà§ÂÆö„Åó„Åæ„Åô
func isStreamingCommand(parsedCmd *parser.ParsedCommand) bool {
	// ÊúÄÂàù„Å´Linux„Ç≥„Éû„É≥„ÉâÂêç„ÅßÂà§ÂÆöÔºàÊúÄÂÑ™ÂÖàÔºâ
	switch parsedCmd.Command {
	case "free":
		// free „ÅØ docker stats --no-stream „Å´„Éû„ÉÉ„Éî„É≥„Ç∞„Åï„Çå„ÇãÔºàÈùû„Çπ„Éà„É™„Éº„Éü„É≥„Ç∞Ôºâ
		return false
	case "top":
		// top „ÅØ docker stats „Å´„Éû„ÉÉ„Éî„É≥„Ç∞„Åï„Çå„ÇãÔºà„Çπ„Éà„É™„Éº„Éü„É≥„Ç∞Ôºâ
		return true
	}

	// ParsedCommand„ÇíDocker„Ç≥„Éû„É≥„ÉâÈÖçÂàó„Å´Â§âÊèõ
	var dockerCmd []string

	// tail -f „Å™„Å©„ÅÆLinux„Ç≥„Éû„É≥„Éâ„ÇíDocker„Ç≥„Éû„É≥„Éâ„Å´Â§âÊèõ„Åó„Å¶„ÉÅ„Çß„ÉÉ„ÇØ
	if parsedCmd.Command == "tail" {
		if _, hasF := parsedCmd.Options["f"]; hasF {
			// tail -f „ÅØ docker logs -f „Å´„Éû„ÉÉ„Éî„É≥„Ç∞„Åï„Çå„Çã
			dockerCmd = []string{"docker", "logs", "-f"}
			dockerCmd = append(dockerCmd, parsedCmd.Args...)
		}
	} else if parsedCmd.Command == "docker" {
		// Êó¢„Å´Docker„Ç≥„Éû„É≥„Éâ„ÅÆÂ†¥Âêà
		dockerCmd = append([]string{"docker"}, parsedCmd.Args...)
	} else {
		// „Åù„ÅÆ‰ªñ„ÅÆ„Ç≥„Éû„É≥„Éâ„ÅÆÂ†¥Âêà„ÄÅÂü∫Êú¨ÁöÑ„Å´„Çπ„Éà„É™„Éº„Éü„É≥„Ç∞„Åß„ÅØ„Å™„ÅÑ
		return false
	}

	// executor package„ÅÆisStreamingCommandÈñ¢Êï∞„ÇíÂà©Áî®
	if len(dockerCmd) >= 2 {
		// docker logs -f „ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ
		if dockerCmd[1] == "logs" {
			for _, arg := range dockerCmd[2:] {
				if arg == "-f" || arg == "--follow" {
					return true
				}
			}
		}

		// docker attach „ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ
		if dockerCmd[1] == "attach" {
			return true
		}

		// docker exec with interactive/tty flags „ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ
		if dockerCmd[1] == "exec" {
			for _, arg := range dockerCmd[2:] {
				if arg == "-it" || arg == "-i" || arg == "-t" {
					return true
				}
			}
		}

		// docker stats „ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ (--no-stream „Åå„Å™„ÅÑÂ†¥Âêà„ÅØ„Çπ„Éà„É™„Éº„Éü„É≥„Ç∞)
		if dockerCmd[1] == "stats" {
			for _, arg := range dockerCmd[2:] {
				if arg == "--no-stream" {
					return false // --no-stream „Åå„ÅÇ„Çå„Å∞„Çπ„Éà„É™„Éº„Éü„É≥„Ç∞„Åß„ÅØ„Å™„ÅÑ
				}
			}
			return true // „Éá„Éï„Ç©„É´„Éà„ÅÆdocker stats„ÅØ„Çπ„Éà„É™„Éº„Éü„É≥„Ç∞
		}
	}

	return false
}

// showHelp „ÅØ„Éò„É´„Éó„ÇíË°®Á§∫„Åó„Åæ„Åô
func (s *Shell) showHelp() {
	fmt.Println(i18n.T("commands.docker_only_help_title"))
	fmt.Println(i18n.T("commands.docker_only_help_description"))
	fmt.Println()
	fmt.Println(i18n.T("commands.docker_only_mappings_title"))
	fmt.Println(i18n.T("commands.examples_header"))
	fmt.Println(i18n.T("commands.examples_ls"))
	fmt.Println(i18n.T("commands.examples_ps"))
	fmt.Println(i18n.T("commands.examples_kill"))
	fmt.Println(i18n.T("commands.examples_rm"))
	fmt.Println(i18n.T("commands.examples_tail"))
	fmt.Println(i18n.T("commands.examples_cd"))
	fmt.Println()
	fmt.Println(i18n.T("commands.docker_only_docker_commands_title"))
	fmt.Println(i18n.T("commands.docker_commands_note"))
	fmt.Println()
	fmt.Println(i18n.T("commands.lifecycle_header"))
	fmt.Println(i18n.T("commands.lifecycle_pull"))
	fmt.Println(i18n.T("commands.lifecycle_start"))
	fmt.Println(i18n.T("commands.lifecycle_stop"))
	fmt.Println(i18n.T("commands.lifecycle_exec"))
	fmt.Println(i18n.T("commands.lifecycle_rm"))
	fmt.Println(i18n.T("commands.lifecycle_rmi"))
	fmt.Println()
	fmt.Println(i18n.T("commands.docker_only_builtin_commands_title"))
	fmt.Println("  help                    " + i18n.T("help.usage"))
	fmt.Println("  mapping [list|search|show] " + i18n.T("commands.mapping_help"))
	fmt.Println("  alias <name>=<command>  " + i18n.T("commands.alias_help"))
	fmt.Println("  theme [name]            " + i18n.T("commands.theme_help"))
	fmt.Println("  config [show]           " + i18n.T("commands.config_help"))
	fmt.Println("  exit                    " + i18n.T("commands.exit_help"))
	fmt.Println()
	fmt.Println(i18n.T("commands.docker_only_more_info_title"))
	fmt.Println("  mapping list            " + i18n.T("commands.mapping_list"))
	fmt.Println("  mapping search <query>  " + i18n.T("commands.mapping_search"))
	fmt.Println("  mapping show <command>  " + i18n.T("commands.mapping_show"))
	fmt.Println()
	fmt.Println(i18n.T("commands.docker_only_note_title") + " " + i18n.T("commands.docker_only_note_message"))
}

// executeStreamingCommandDirectly „ÅØgo-prompt„Çí„Éê„Ç§„Éë„Çπ„Åó„Å¶„Çπ„Éà„É™„Éº„Éü„É≥„Ç∞„Ç≥„Éû„É≥„Éâ„ÇíÁõ¥Êé•ÂÆüË°å„Åó„Åæ„Åô
func (s *Shell) executeStreamingCommandDirectly(parsedCmd *parser.ParsedCommand) error {
	// „Éû„ÉÉ„Éî„É≥„Ç∞„ÇíËß£Ê±∫
	var dockerCmd []string
	var mapping *engine.CommandMapping

	if parsedCmd.Command == "tail" && parsedCmd.Options["f"] == "true" {
		// tail -f „Çídocker logs -f „Å´„Éû„ÉÉ„Éî„É≥„Ç∞
		var err error
		mapping, err = s.mappingEngine.FindByLinuxCommand("tail -f")
		if err != nil {
			fmt.Printf("‚ùå tail -f mapping not found: %s\n", err.Error())
			return err
		}
		dockerCmd = strings.Fields(mapping.DockerCommand)
		dockerCmd = append(dockerCmd, parsedCmd.Args...)
	} else if parsedCmd.Command == "docker" {
		// Áõ¥Êé•Docker„Ç≥„Éû„É≥„Éâ
		dockerCmd = append([]string{"docker"}, parsedCmd.Args...)
	} else {
		return fmt.Errorf("unsupported streaming command: %s", parsedCmd.Command)
	}

	fmt.Printf(i18n.T("app.executing")+"\n", strings.Join(dockerCmd, " "))
	if mapping != nil {
		fmt.Printf(i18n.T("app.mapping_applied")+"\n", mapping.LinuxCommand, mapping.DockerCommand)
	}
	fmt.Println(i18n.T("app.stream_stop_tip"))

	// „Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Åßgoroutine„ÅÆÂçîË™øÁöÑÁµÇ‰∫Ü„ÇíÂà∂Âæ°
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Docker„Ç≥„Éû„É≥„Éâ„Çí‰ΩúÊàê
	cmd := exec.CommandContext(ctx, dockerCmd[0], dockerCmd[1:]...)
	cmd.SysProcAttr = &syscall.SysProcAttr{
		Setpgid: true,
	}

	// „Éë„Ç§„Éó„Çí‰ΩúÊàê„Åó„Å¶stdin/stdout/stderr„ÇíÂà∂Âæ°
	stdin, err := cmd.StdinPipe()
	if err != nil {
		return fmt.Errorf("failed to create stdin pipe: %w", err)
	}

	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	// „Ç≥„Éû„É≥„Éâ„ÇíÈñãÂßã
	if err := cmd.Start(); err != nil {
		return fmt.Errorf("failed to start command: %w", err)
	}

	// Ë§áÊï∞„ÅÆÁµÇ‰∫ÜÁõ£Ë¶ñ„Çí‰∏¶Ë°åÂÆüË°å
	terminationChan := make(chan string, 5)

	// 1. Ê®ôÊ∫ñÁöÑ„Å™„Ç∑„Ç∞„Éä„É´Âá¶ÁêÜ
	go s.watchForSignals(ctx, terminationChan)

	// 2. „Éó„É≠„Çª„ÇπÂÆå‰∫ÜÁõ£Ë¶ñ
	go func() {
		err := cmd.Wait()
		if err != nil {
			terminationChan <- fmt.Sprintf("process_error:%v", err)
		} else {
			terminationChan <- "process_completed"
		}
	}()

	// 3. Ê®ôÊ∫ñÂÖ•ÂäõÁõ£Ë¶ñÔºàexit „Ç≥„Éû„É≥„ÉâÁî®Ôºâ
	go s.watchForStdinExit(ctx, terminationChan)

	// 4. Á∑äÊÄ•ÊôÇ„ÅÆ„Éó„É≠„Çª„ÇπÁõ£Ë¶ñ
	go s.emergencyProcessMonitor(ctx, cmd, terminationChan)

	// 5. „Çø„Ç§„É†„Ç¢„Ç¶„ÉàÁõ£Ë¶ñÔºàÊ•µÁ´Ø„Å´Èï∑„ÅÑÂ†¥Âêà„ÅÆ‰øùË≠∑Ôºâ
	go func() {
		select {
		case <-time.After(30 * time.Minute):
			terminationChan <- "timeout"
		case <-ctx.Done():
			return
		}
	}()

	// ÁµÇ‰∫ÜÁêÜÁî±„ÇíÂæÖÊ©ü
	reason := <-terminationChan

	// ÂÖ®„Å¶„ÅÆgoroutine„ÇíÂÅúÊ≠¢
	cancel()

	// „Éó„É≠„Çª„ÇπÁµÇ‰∫ÜÂá¶ÁêÜ
	s.cleanupProcess(cmd, stdin)

	switch {
	case strings.HasPrefix(reason, "signal"):
		fmt.Println(i18n.T("app.command_stopped_signal"))
	case reason == "stdin_exit":
		fmt.Println(i18n.T("app.command_stopped"))
	case reason == "stdin_force_kill":
		fmt.Println(i18n.T("app.command_force_killed"))
	case reason == "stdin_stop":
		fmt.Println(i18n.T("app.command_stopped_manual"))
	case reason == "process_completed":
		fmt.Println(i18n.T("app.command_completed"))
	case strings.HasPrefix(reason, "process_error"):
		fmt.Printf(i18n.T("app.command_failed_reason")+"\n", strings.TrimPrefix(reason, "process_error:"))
	case reason == "timeout":
		fmt.Println(i18n.T("app.command_timed_out"))
	case reason == "emergency":
		fmt.Println(i18n.T("app.command_stopped_alert"))
	case reason == "emergency_auto_terminate":
		fmt.Println(i18n.T("app.command_auto_terminated"))
	case reason == "process_already_exited":
		fmt.Println(i18n.T("app.command_exited"))
	}

	return nil
}

// watchForSignals „ÅØÊßò„ÄÖ„Å™ÊñπÊ≥ï„Åß„Ç∑„Ç∞„Éä„É´„ÇíÁõ£Ë¶ñ„Åó„Åæ„Åô
func (s *Shell) watchForSignals(ctx context.Context, terminationChan chan string) {

	// Ë§áÊï∞„ÅÆ„Ç∑„Ç∞„Éä„É´„ÉÅ„É£„É≥„Éç„É´„Çí‰ΩúÊàê
	sigChan1 := make(chan os.Signal, 5)
	sigChan2 := make(chan os.Signal, 5)
	sigChan3 := make(chan os.Signal, 5)

	// „Çà„ÇäÂ§ö„Åè„ÅÆ„Ç∑„Ç∞„Éä„É´„Çø„Ç§„Éó„ÇíÁõ£Ë¶ñ
	signal.Notify(sigChan1, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)
	signal.Notify(sigChan2, syscall.SIGINT, syscall.SIGHUP, syscall.SIGQUIT)
	signal.Notify(sigChan3, syscall.SIGTERM, os.Interrupt, syscall.SIGINT, syscall.SIGKILL)

	// „Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Ç≠„É£„É≥„Çª„É´ÊôÇ„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
	defer func() {
		signal.Stop(sigChan1)
		signal.Stop(sigChan2)
		signal.Stop(sigChan3)
	}()

	// Ë§áÊï∞„ÅÆÁõ£Ë¶ñgoroutine„ÇíËµ∑Âãï
	go func() {
		for {
			select {
			case sig := <-sigChan1:
				terminationChan <- fmt.Sprintf("signal_1:%v", sig)
				return
			case <-ctx.Done():
				return
			}
		}
	}()

	go func() {
		for {
			select {
			case sig := <-sigChan2:
				terminationChan <- fmt.Sprintf("signal_2:%v", sig)
				return
			case <-ctx.Done():
				return
			}
		}
	}()

	go func() {
		for {
			select {
			case sig := <-sigChan3:
				terminationChan <- fmt.Sprintf("signal_3:%v", sig)
				return
			case <-ctx.Done():
				return
			}
		}
	}()

	// „Ç≠„Éº„Éú„Éº„ÉâÂâ≤„ÇäËæº„ÅøÊ§úÂá∫„ÅÆÂà•„Ç¢„Éó„É≠„Éº„ÉÅ
	go func() {
		ticker := time.NewTicker(50 * time.Millisecond)
		defer ticker.Stop()

		for {
			select {
			case <-ticker.C:
				// /proc/self/status „ÅßÂâ≤„ÇäËæº„ÅøÁä∂ÊÖã„Çí„ÉÅ„Çß„ÉÉ„ÇØÔºàLinux„ÅÆ„ÅøÔºâ
				if data, err := os.ReadFile("/proc/self/status"); err == nil {
					status := string(data)
					if strings.Contains(status, "SigPnd:") && !strings.Contains(status, "SigPnd:\t0000000000000000") {
						terminationChan <- "signal_proc_check"
						return
					}
				}
			case <-ctx.Done():
				return
			}
		}
	}()

	// ÊúÄÂæå„ÅÆÊâãÊÆµÔºöÂÆöÊúüÁöÑ„Å´„Éó„É≠„Çª„Çπ„ÅÆË¶™„Éó„É≠„Çª„Çπ„Çí„ÉÅ„Çß„ÉÉ„ÇØ
	go func() {
		ticker := time.NewTicker(100 * time.Millisecond)
		defer ticker.Stop()
		originalPpid := os.Getppid()

		for {
			select {
			case <-ticker.C:
				currentPpid := os.Getppid()
				if currentPpid != originalPpid {
					terminationChan <- "signal_orphan"
					return
				}
			case <-ctx.Done():
				return
			}
		}
	}()
}

// watchForStdinExit „ÅØÊ®ôÊ∫ñÂÖ•Âäõ„Åã„Çâ exit „Ç≥„Éû„É≥„Éâ„ÇíÁõ£Ë¶ñ„Åó„Åæ„Åô
func (s *Shell) watchForStdinExit(ctx context.Context, terminationChan chan string) {

	// „Éê„ÉÉ„Éï„Ç°„É™„É≥„Ç∞„Åó„Å¶ÊñáÂ≠óÂàó„ÇíÁµÑ„ÅøÁ´ã„Å¶
	go func() {
		inputBuffer := ""
		buffer := make([]byte, 1)

		for {
			select {
			case <-ctx.Done():
				return
			default:
				// 1ÊñáÂ≠ó„Åö„Å§Ë™≠„ÅøÂèñ„ÇäÔºàÈùû„Éñ„É≠„ÉÉ„Ç≠„É≥„Ç∞Ë™≠„ÅøÂèñ„Çä„ÅÆË©¶Ë°åÔºâ
				n, err := os.Stdin.Read(buffer)
				if err != nil {
					time.Sleep(10 * time.Millisecond) // CPU‰ΩøÁî®Áéá„Çí‰∏ã„Åí„Çã
					continue
				}

				if n > 0 {
					char := string(buffer[0])

					// Enter„Ç≠„ÉºÔºàÊîπË°åÔºâ„ÅÆÂá¶ÁêÜ
					if char == "\n" || char == "\r" {
						if inputBuffer == "exit" || inputBuffer == "quit" || inputBuffer == "q" {
							terminationChan <- "stdin_exit"
							return
						} else if inputBuffer == "KILL" || inputBuffer == "kill" {
							terminationChan <- "stdin_force_kill"
							return
						} else if inputBuffer == "STOP" || inputBuffer == "stop" {
							terminationChan <- "stdin_stop"
							return
						}
						inputBuffer = "" // „É™„Çª„ÉÉ„Éà
					} else if char >= " " && char <= "~" { // Âç∞Âà∑ÂèØËÉΩÊñáÂ≠ó„ÅÆ„Åø
						inputBuffer += char
					}
				}
			}
		}
	}()
}

// emergencyProcessMonitor „ÅØÁ∑äÊÄ•ÊôÇ„ÅÆ„Éó„É≠„Çª„ÇπÁõ£Ë¶ñ„ÇíË°å„ÅÑ„Åæ„Åô
func (s *Shell) emergencyProcessMonitor(ctx context.Context, cmd *exec.Cmd, terminationChan chan string) {
	ticker := time.NewTicker(30 * time.Second) // 30ÁßíÈñìÈöî„Å´Â§âÊõ¥
	defer ticker.Stop()

	emergencyCount := 0
	for {
		select {
		case <-ticker.C:
			emergencyCount++

			// „Éó„É≠„Çª„Çπ„Åå„Çæ„É≥„ÉìÂåñ„Åó„Å¶„ÅÑ„Å™„ÅÑ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
			if cmd.ProcessState != nil && cmd.ProcessState.Exited() {
				terminationChan <- "emergency"
				return
			}

			// 1ÂàÜÂæå„Å´‰∏ÄÂ∫¶„Å†„Åë‰ª£ÊõøÊâãÊÆµ„ÇíÊèêÁ§∫
			if emergencyCount == 2 { // 1ÂàÜÁµåÈÅé
				fmt.Println("\nüí° Alternative commands: 'exit', 'stop', or 'kill' + Enter")
			}

			// Èï∑ÊôÇÈñìÂãï‰Ωú„Åó„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅÆËá™ÂãïÁµÇ‰∫Ü
			if emergencyCount >= 10 { // 5ÂàÜÁµåÈÅé
				terminationChan <- "emergency_auto_terminate"
				return
			}
		case <-ctx.Done():
			return
		}
	}
}

// cleanupProcess „ÅØ„Éó„É≠„Çª„Çπ„ÇíÁ¢∫ÂÆü„Å´ÁµÇ‰∫Ü„Åï„Åõ„Åæ„Åô
func (s *Shell) cleanupProcess(cmd *exec.Cmd, stdin interface{}) {
	if stdin != nil {
		if closer, ok := stdin.(io.WriteCloser); ok {
			closer.Close()
		}
	}

	if cmd.Process == nil {
		return
	}

	pid := cmd.Process.Pid

	// ÊÆµÈöéÁöÑÁµÇ‰∫Ü
	steps := []struct {
		name   string
		signal os.Signal
		wait   time.Duration
	}{
		{"SIGTERM to process group", syscall.SIGTERM, 200 * time.Millisecond},
		{"SIGKILL to process group", syscall.SIGKILL, 100 * time.Millisecond},
	}

	for _, step := range steps {
		if cmd.ProcessState != nil && cmd.ProcessState.Exited() {
			break
		}

		// „Éó„É≠„Çª„Çπ„Ç∞„É´„Éº„Éó„Å´ÈÄÅ‰ø°
		if err := syscall.Kill(-pid, step.signal.(syscall.Signal)); err != nil {
			// ÂÄãÂà•„Éó„É≠„Çª„Çπ„Å´ÈÄÅ‰ø°
			if step.signal == syscall.SIGKILL {
				cmd.Process.Kill()
			} else {
				cmd.Process.Signal(step.signal)
			}
		}

		time.Sleep(step.wait)
	}
}
